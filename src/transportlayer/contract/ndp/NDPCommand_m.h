//
// Generated file, do not edit! Created by nedtool 5.6 from transportlayer/contract/ndp/NDPCommand.msg.
//

#ifndef __INET_NDPCOMMAND_M_H
#define __INET_NDPCOMMAND_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif


namespace inet {

class NDPCommand;
class NDPErrorInfo;
class NDPOpenCommand;
class NDPAcceptCommand;
class NDPSendCommand;
class NDPAvailableInfo;
class NDPConnectInfo;
class NDPStatusInfo;
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/networklayer/common/IpProtocolId_m.h" // import inet.networklayer.common.IpProtocolId

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address


namespace inet {

/**
 * Enum generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:17</tt> by nedtool.
 * <pre>
 * //
 * // NDPR command codes, sent by the application to NDPR. These constants
 * // should be set as message kind on a message sent to the NDPR entity.
 * //
 * // \@see ~NDPRCommand, ~NDPROpenCommand, ~IRaptoNDP
 * //
 * enum NDPCommandCode
 * {
 *     NDP_C_OPEN_ACTIVE = 1;   // active open (must carry ~NDPOpenCommand)
 *     NDP_C_OPEN_PASSIVE = 2;  // passive open (must carry ~NDPOpenCommand)
 *     NDP_C_ACCEPT = 3;
 *     NDP_C_SEND = 4;          // send data (set on data packet)
 *     NDP_C_CLOSE = 5;         // "I have no more data to send"
 *     NDP_C_ABORT = 6;         // abort connection
 *     NDP_C_STATUS = 7;        // request status info (NDP_I_STATUS) from NDP
 *     NDP_C_QUEUE_BYTES_LIMIT = 8; // set send queue limit (in bytes)
 *     NDP_C_READ = 9;       // send request to NDP to deliver data
 *     NDP_C_DESTROY = 10;      // send request to NDP to destroy the socket descriptor
 *     NDP_SETOPTION = 11;    // setting NDP socket options
 * }
 * </pre>
 */
enum NDPCommandCode {
    NDP_C_OPEN_ACTIVE = 1,
    NDP_C_OPEN_PASSIVE = 2,
    NDP_C_ACCEPT = 3,
    NDP_C_SEND = 4,
    NDP_C_CLOSE = 5,
    NDP_C_ABORT = 6,
    NDP_C_STATUS = 7,
    NDP_C_QUEUE_BYTES_LIMIT = 8,
    NDP_C_READ = 9,
    NDP_C_DESTROY = 10,
    NDP_SETOPTION = 11
};

/**
 * Enum generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:39</tt> by nedtool.
 * <pre>
 * //
 * // NDP indications, sent by NDP to the application. NDP will set these
 * // constants as message kind on messages it sends to the application.
 * //
 * // \@see ~NDPCommand, ~NDPStatusInfo, ~INDP
 * //
 * enum NDPStatusInd
 * {
 *     NDP_I_DATA = 1;              // data packet (set on data packet)
 *     NDP_I_URGENT_DATA = 2;       // urgent data (set on data packet)
 *     NDP_I_AVAILABLE = 3;         // conncetion available
 *     NDP_I_ESTABLISHED = 4;       // connection established
 *     NDP_I_PEER_CLOSED = 5;       // FIN received from remote NDP
 *     NDP_I_CLOSED = 6;            // connection closed normally (via FIN exchange)
 *     NDP_I_CONNECTION_REFUSED = 7; // connection refused
 *     NDP_I_CONNECTION_RESET = 8;  // connection reset
 *     NDP_I_TIMED_OUT = 9;         // conn-estab timer went off, or max retransm. count reached
 *     NDP_I_STATUS = 10;            // status info (will carry ~NDPStatusInfo)
 *     NDP_I_SEND_MSG = 11;         // send queue abated, send more messages
 *     NDP_I_DATA_NOTIFICATION = 12; // notify the upper layer that data has arrived
 * }
 * </pre>
 */
enum NDPStatusInd {
    NDP_I_DATA = 1,
    NDP_I_URGENT_DATA = 2,
    NDP_I_AVAILABLE = 3,
    NDP_I_ESTABLISHED = 4,
    NDP_I_PEER_CLOSED = 5,
    NDP_I_CLOSED = 6,
    NDP_I_CONNECTION_REFUSED = 7,
    NDP_I_CONNECTION_RESET = 8,
    NDP_I_TIMED_OUT = 9,
    NDP_I_STATUS = 10,
    NDP_I_SEND_MSG = 11,
    NDP_I_DATA_NOTIFICATION = 12
};

/**
 * Enum generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:59</tt> by nedtool.
 * <pre>
 * //
 * // Currently not in use.
 * //
 * enum NDPErrorCode
 * {
 * }
 * </pre>
 */
enum NDPErrorCode {
};

/**
 * Class generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:64</tt> by nedtool.
 * <pre>
 * class NDPCommand extends cObject
 * {
 *     int userId = -1;   // id than can be freely used by the app
 * 
 *     unsigned int numRcvTrimmedHeader = 0;
 * }
 * </pre>
 */
class NDPCommand : public ::omnetpp::cObject
{
  protected:
    int userId = -1;
    unsigned int numRcvTrimmedHeader = 0;

  private:
    void copy(const NDPCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPCommand&);

  public:
    NDPCommand();
    NDPCommand(const NDPCommand& other);
    virtual ~NDPCommand();
    NDPCommand& operator=(const NDPCommand& other);
    virtual NDPCommand *dup() const override {return new NDPCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getUserId() const;
    virtual void setUserId(int userId);
    virtual unsigned int getNumRcvTrimmedHeader() const;
    virtual void setNumRcvTrimmedHeader(unsigned int numRcvTrimmedHeader);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:72</tt> by nedtool.
 * <pre>
 * class NDPErrorInfo extends NDPCommand
 * {
 *     NDPErrorCode errorCode;
 *     string messageText;
 * }
 * </pre>
 */
class NDPErrorInfo : public ::inet::NDPCommand
{
  protected:
    inet::NDPErrorCode errorCode = static_cast<inet::NDPErrorCode>(-1);
    omnetpp::opp_string messageText;

  private:
    void copy(const NDPErrorInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPErrorInfo&);

  public:
    NDPErrorInfo();
    NDPErrorInfo(const NDPErrorInfo& other);
    virtual ~NDPErrorInfo();
    NDPErrorInfo& operator=(const NDPErrorInfo& other);
    virtual NDPErrorInfo *dup() const override {return new NDPErrorInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::NDPErrorCode getErrorCode() const;
    virtual void setErrorCode(inet::NDPErrorCode errorCode);
    virtual const char * getMessageText() const;
    virtual void setMessageText(const char * messageText);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPErrorInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPErrorInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:79</tt> by nedtool.
 * <pre>
 * class NDPOpenCommand extends NDPCommand
 * {
 *     L3Address localAddr;
 *     L3Address remoteAddr;
 *     int localPort = -1;
 *     int remotePort = -1;
 *     bool fork = false;
 *     string ndpAlgorithmClass;
 * 
 *     unsigned int priorityValue;
 *     unsigned int numPacketsToSend;
 *     bool isLongFlow;
 *     bool isSender;
 *     bool isReceiver;
 * }
 * </pre>
 */
class NDPOpenCommand : public ::inet::NDPCommand
{
  protected:
    L3Address localAddr;
    L3Address remoteAddr;
    int localPort = -1;
    int remotePort = -1;
    bool fork = false;
    omnetpp::opp_string ndpAlgorithmClass;
    unsigned int priorityValue = 0;
    unsigned int numPacketsToSend = 0;
    bool isLongFlow_ = false;
    bool isSender_ = false;
    bool isReceiver_ = false;

  private:
    void copy(const NDPOpenCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPOpenCommand&);

  public:
    NDPOpenCommand();
    NDPOpenCommand(const NDPOpenCommand& other);
    virtual ~NDPOpenCommand();
    NDPOpenCommand& operator=(const NDPOpenCommand& other);
    virtual NDPOpenCommand *dup() const override {return new NDPOpenCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const L3Address& getLocalAddr() const;
    virtual L3Address& getLocalAddrForUpdate() { return const_cast<L3Address&>(const_cast<NDPOpenCommand*>(this)->getLocalAddr());}
    virtual void setLocalAddr(const L3Address& localAddr);
    virtual const L3Address& getRemoteAddr() const;
    virtual L3Address& getRemoteAddrForUpdate() { return const_cast<L3Address&>(const_cast<NDPOpenCommand*>(this)->getRemoteAddr());}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
    virtual bool getFork() const;
    virtual void setFork(bool fork);
    virtual const char * getNdpAlgorithmClass() const;
    virtual void setNdpAlgorithmClass(const char * ndpAlgorithmClass);
    virtual unsigned int getPriorityValue() const;
    virtual void setPriorityValue(unsigned int priorityValue);
    virtual unsigned int getNumPacketsToSend() const;
    virtual void setNumPacketsToSend(unsigned int numPacketsToSend);
    virtual bool isLongFlow() const;
    virtual void setIsLongFlow(bool isLongFlow);
    virtual bool isSender() const;
    virtual void setIsSender(bool isSender);
    virtual bool isReceiver() const;
    virtual void setIsReceiver(bool isReceiver);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPOpenCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPOpenCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:95</tt> by nedtool.
 * <pre>
 * class NDPAcceptCommand extends NDPCommand
 * {
 * }
 * </pre>
 */
class NDPAcceptCommand : public ::inet::NDPCommand
{
  protected:

  private:
    void copy(const NDPAcceptCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPAcceptCommand&);

  public:
    NDPAcceptCommand();
    NDPAcceptCommand(const NDPAcceptCommand& other);
    virtual ~NDPAcceptCommand();
    NDPAcceptCommand& operator=(const NDPAcceptCommand& other);
    virtual NDPAcceptCommand *dup() const override {return new NDPAcceptCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPAcceptCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPAcceptCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:100</tt> by nedtool.
 * <pre>
 * class NDPSendCommand extends NDPCommand
 * {
 * }
 * </pre>
 */
class NDPSendCommand : public ::inet::NDPCommand
{
  protected:

  private:
    void copy(const NDPSendCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPSendCommand&);

  public:
    NDPSendCommand();
    NDPSendCommand(const NDPSendCommand& other);
    virtual ~NDPSendCommand();
    NDPSendCommand& operator=(const NDPSendCommand& other);
    virtual NDPSendCommand *dup() const override {return new NDPSendCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPSendCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPSendCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:104</tt> by nedtool.
 * <pre>
 * class NDPAvailableInfo extends NDPCommand
 * {
 *     L3Address localAddr;
 *     L3Address remoteAddr;
 *     int localPort;
 *     int remotePort;
 *     int newSocketId;
 * }
 * </pre>
 */
class NDPAvailableInfo : public ::inet::NDPCommand
{
  protected:
    L3Address localAddr;
    L3Address remoteAddr;
    int localPort = 0;
    int remotePort = 0;
    int newSocketId = 0;

  private:
    void copy(const NDPAvailableInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPAvailableInfo&);

  public:
    NDPAvailableInfo();
    NDPAvailableInfo(const NDPAvailableInfo& other);
    virtual ~NDPAvailableInfo();
    NDPAvailableInfo& operator=(const NDPAvailableInfo& other);
    virtual NDPAvailableInfo *dup() const override {return new NDPAvailableInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const L3Address& getLocalAddr() const;
    virtual L3Address& getLocalAddrForUpdate() { return const_cast<L3Address&>(const_cast<NDPAvailableInfo*>(this)->getLocalAddr());}
    virtual void setLocalAddr(const L3Address& localAddr);
    virtual const L3Address& getRemoteAddr() const;
    virtual L3Address& getRemoteAddrForUpdate() { return const_cast<L3Address&>(const_cast<NDPAvailableInfo*>(this)->getRemoteAddr());}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
    virtual int getNewSocketId() const;
    virtual void setNewSocketId(int newSocketId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPAvailableInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPAvailableInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:113</tt> by nedtool.
 * <pre>
 * class NDPConnectInfo extends NDPCommand
 * {
 *     L3Address localAddr;
 *     L3Address remoteAddr;
 *     int localPort;
 *     int remotePort;
 * }
 * </pre>
 */
class NDPConnectInfo : public ::inet::NDPCommand
{
  protected:
    L3Address localAddr;
    L3Address remoteAddr;
    int localPort = 0;
    int remotePort = 0;

  private:
    void copy(const NDPConnectInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPConnectInfo&);

  public:
    NDPConnectInfo();
    NDPConnectInfo(const NDPConnectInfo& other);
    virtual ~NDPConnectInfo();
    NDPConnectInfo& operator=(const NDPConnectInfo& other);
    virtual NDPConnectInfo *dup() const override {return new NDPConnectInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const L3Address& getLocalAddr() const;
    virtual L3Address& getLocalAddrForUpdate() { return const_cast<L3Address&>(const_cast<NDPConnectInfo*>(this)->getLocalAddr());}
    virtual void setLocalAddr(const L3Address& localAddr);
    virtual const L3Address& getRemoteAddr() const;
    virtual L3Address& getRemoteAddrForUpdate() { return const_cast<L3Address&>(const_cast<NDPConnectInfo*>(this)->getRemoteAddr());}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPConnectInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPConnectInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/contract/ndp/NDPCommand.msg:122</tt> by nedtool.
 * <pre>
 * class NDPStatusInfo extends NDPCommand
 * {
 *     int state;
 *     string stateName;
 * 
 *     L3Address localAddr;
 *     L3Address remoteAddr;
 *     int localPort;
 *     int remotePort;
 * 
 *     unsigned int snd_mss;
 * 
 * }
 * </pre>
 */
class NDPStatusInfo : public ::inet::NDPCommand
{
  protected:
    int state = 0;
    omnetpp::opp_string stateName;
    L3Address localAddr;
    L3Address remoteAddr;
    int localPort = 0;
    int remotePort = 0;
    unsigned int snd_mss = 0;

  private:
    void copy(const NDPStatusInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPStatusInfo&);

  public:
    NDPStatusInfo();
    NDPStatusInfo(const NDPStatusInfo& other);
    virtual ~NDPStatusInfo();
    NDPStatusInfo& operator=(const NDPStatusInfo& other);
    virtual NDPStatusInfo *dup() const override {return new NDPStatusInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getState() const;
    virtual void setState(int state);
    virtual const char * getStateName() const;
    virtual void setStateName(const char * stateName);
    virtual const L3Address& getLocalAddr() const;
    virtual L3Address& getLocalAddrForUpdate() { return const_cast<L3Address&>(const_cast<NDPStatusInfo*>(this)->getLocalAddr());}
    virtual void setLocalAddr(const L3Address& localAddr);
    virtual const L3Address& getRemoteAddr() const;
    virtual L3Address& getRemoteAddrForUpdate() { return const_cast<L3Address&>(const_cast<NDPStatusInfo*>(this)->getRemoteAddr());}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
    virtual unsigned int getSnd_mss() const;
    virtual void setSnd_mss(unsigned int snd_mss);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPStatusInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPStatusInfo& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_NDPCOMMAND_M_H

