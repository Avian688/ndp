//
// Generated file, do not edit! Created by nedtool 5.6 from transportlayer/Ndp/ndp_common/NDPSegment.msg.
//

#ifndef __INET__NDP_NDPSEGMENT_M_H
#define __INET__NDP_NDPSEGMENT_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include <iostream>
#include "inet/common/INETDefs.h"
#include "inet/common/ByteArray.h"

namespace inet {
namespace ndp {
class Sack;
class NDPOption;
typedef NDPOption *NDPOptionPtr;
}
}
// }}


namespace inet {
namespace ndp {

// cplusplus {{
    // default NDP header length: 20 bytes
    #define NDP_HEADER_OCTETS  20    // without options

    // maximum NDP header length (base + options): 60 = 4 * 15 bytes
    const unsigned int NDP_MAX_HEADER_OCTETS = 60;

    // maximum allowed sack entry number, if no other options are used
    const unsigned int MAX_SACK_ENTRIES = 4;

    typedef cPacket *cPacketPtr;

    inline std::ostream& operator<<(std::ostream& os, cPacketPtr msg)
    {
        return os << "(" << msg->getClassName() << ") " << msg->getName() << ": " << msg->info();
    }

    inline void doPacking(cCommBuffer *b, cPacketPtr& msg) {msg->parsimPack(b);}
    inline void doUnpacking(cCommBuffer *b, cPacketPtr& msg) {msg->parsimUnpack(b);}
// }}

/**
 * Struct generated from transportlayer/Ndp/ndp_common/NDPSegment.msg:45 by nedtool.
 */
struct NDPPayloadMessage
{
    NDPPayloadMessage();
    unsigned int endSequenceNo;
    cPacketPtr msg;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const NDPPayloadMessage& a);
void __doUnpacking(omnetpp::cCommBuffer *b, NDPPayloadMessage& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPPayloadMessage& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPPayloadMessage& obj) { __doUnpacking(b, obj); }

/**
 * Enum generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:58</tt> by nedtool.
 * <pre>
 * //
 * // NDP Option Numbers
 * // Reference: http://www.iana.org/assignments/tcp-parameters/
 * // Date: 2011-07-02
 * //
 * // Note: Options not yet implemented should stay commented out
 * //
 * enum NDPOptionNumbers
 * {
 *     NDPOPTION_END_OF_OPTION_LIST = 0;                   // RFC 793, LENGTH: 1 Byte
 *     NDPOPTION_NO_OPERATION = 1;                         // RFC 793, LENGTH: 1 Byte
 *     NDPOPTION_MAXIMUM_SEGMENT_SIZE = 2;                 // RFC 793, LENGTH: 4 Bytes
 *     NDPOPTION_WINDOW_SCALE = 3;                         // RFC 1323, LENGTH: 3 Bytes
 *     NDPOPTION_SACK_PERMITTED = 4;                       // RFC 2018, LENGTH: 2 Bytes
 *     NDPOPTION_SACK = 5;                                 // RFC 2018, LENGTH: N (max. N = 4) 8 * n + 2 Bytes  => 32 + 2 + 2 * NOP = 36 Bytes; If TIMESTAMP option is used with SACK: max. n = 3 => 12 Bytes (for Timestamp) + 28 Bytes (for SACK) = 40 Bytes
 *     NDPOPTION_TIMESTAMP = 8;                            // RFC 1323, LENGTH: 10 Bytes
 * 
 * }
 * </pre>
 */
enum NDPOptionNumbers {
    NDPOPTION_END_OF_OPTION_LIST = 0,
    NDPOPTION_NO_OPERATION = 1,
    NDPOPTION_MAXIMUM_SEGMENT_SIZE = 2,
    NDPOPTION_WINDOW_SCALE = 3,
    NDPOPTION_SACK_PERMITTED = 4,
    NDPOPTION_SACK = 5,
    NDPOPTION_TIMESTAMP = 8
};

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:73</tt> by nedtool.
 * <pre>
 * //
 * // This structure represents a single SACK (selective acknowledgment):
 * //
 * class SackItem
 * {
 *     \@fieldNameSuffix("_var"); //TODO remove when OMNeT++ 4.x compatibility is no longer required
 *     unsigned int start;     // start seq no. of sack block
 *     unsigned int end;       // end seq no. of sack block
 * }
 * </pre>
 */
class SackItem : public ::omnetpp::cObject
{
  protected:
    unsigned int start_var;
    unsigned int end_var;

  private:
    void copy(const SackItem& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SackItem&);

  public:
    SackItem();
    SackItem(const SackItem& other);
    virtual ~SackItem();
    SackItem& operator=(const SackItem& other);
    virtual SackItem *dup() const override {return new SackItem(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getStart() const;
    virtual void setStart(unsigned int start);
    virtual unsigned int getEnd() const;
    virtual void setEnd(unsigned int end);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SackItem& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SackItem& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:80</tt> by nedtool.
 * <pre>
 * class Sack extends SackItem
 * {
 *     \@customize(true);
 * }
 * </pre>
 *
 * Sack_Base is only useful if it gets subclassed, and Sack is derived from it.
 * The minimum code to be written for Sack is the following:
 *
 * <pre>
 * class Sack : public Sack_Base
 * {
 *   private:
 *     void copy(const Sack& other) { ... }

 *   public:
 *     Sack() : Sack_Base() {}
 *     Sack(const Sack& other) : Sack_Base(other) {copy(other);}
 *     Sack& operator=(const Sack& other) {if (this==&other) return *this; Sack_Base::operator=(other); copy(other); return *this;}
 *     virtual Sack *dup() const override {return new Sack(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from Sack_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(Sack)
 * </pre>
 */
class Sack_Base : public ::inet::ndp::SackItem
{
  protected:

  private:
    void copy(const Sack_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Sack_Base&);
    // make constructors protected to avoid instantiation
    Sack_Base();
    Sack_Base(const Sack_Base& other);
    // make assignment operator protected to force the user override it
    Sack_Base& operator=(const Sack_Base& other);

  public:
    virtual ~Sack_Base();
    virtual Sack_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class Sack");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:87</tt> by nedtool.
 * <pre>
 * class NDPOption
 * {
 *     unsigned short kind \@enum(NDPOptionNumbers) = -1;  // option kind
 *     unsigned short length = 1;                    // option length
 * }
 * </pre>
 */
class NDPOption : public ::omnetpp::cObject
{
  protected:
    unsigned short kind;
    unsigned short length;

  private:
    void copy(const NDPOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPOption&);

  public:
    NDPOption();
    NDPOption(const NDPOption& other);
    virtual ~NDPOption();
    NDPOption& operator=(const NDPOption& other);
    virtual NDPOption *dup() const override {return new NDPOption(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getKind() const;
    virtual void setKind(unsigned short kind);
    virtual unsigned short getLength() const;
    virtual void setLength(unsigned short length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPOption& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:93</tt> by nedtool.
 * <pre>
 * class NDPOptionEnd extends NDPOption
 * {
 *     kind = NDPOPTION_END_OF_OPTION_LIST;
 *     length = 1;
 * }
 * </pre>
 */
class NDPOptionEnd : public ::inet::ndp::NDPOption
{
  protected:

  private:
    void copy(const NDPOptionEnd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPOptionEnd&);

  public:
    NDPOptionEnd();
    NDPOptionEnd(const NDPOptionEnd& other);
    virtual ~NDPOptionEnd();
    NDPOptionEnd& operator=(const NDPOptionEnd& other);
    virtual NDPOptionEnd *dup() const override {return new NDPOptionEnd(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPOptionEnd& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPOptionEnd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:99</tt> by nedtool.
 * <pre>
 * class NDPOptionNop extends NDPOption
 * {
 *     kind = NDPOPTION_NO_OPERATION;
 *     length = 1;
 * }
 * </pre>
 */
class NDPOptionNop : public ::inet::ndp::NDPOption
{
  protected:

  private:
    void copy(const NDPOptionNop& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPOptionNop&);

  public:
    NDPOptionNop();
    NDPOptionNop(const NDPOptionNop& other);
    virtual ~NDPOptionNop();
    NDPOptionNop& operator=(const NDPOptionNop& other);
    virtual NDPOptionNop *dup() const override {return new NDPOptionNop(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPOptionNop& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPOptionNop& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:105</tt> by nedtool.
 * <pre>
 * class NDPOptionMaxSegmentSize extends NDPOption
 * {
 *     kind = NDPOPTION_MAXIMUM_SEGMENT_SIZE;
 *     length = 4;
 *     uint16_t maxSegmentSize;   // uint16_t
 * }
 * </pre>
 */
class NDPOptionMaxSegmentSize : public ::inet::ndp::NDPOption
{
  protected:
    uint16_t maxSegmentSize;

  private:
    void copy(const NDPOptionMaxSegmentSize& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPOptionMaxSegmentSize&);

  public:
    NDPOptionMaxSegmentSize();
    NDPOptionMaxSegmentSize(const NDPOptionMaxSegmentSize& other);
    virtual ~NDPOptionMaxSegmentSize();
    NDPOptionMaxSegmentSize& operator=(const NDPOptionMaxSegmentSize& other);
    virtual NDPOptionMaxSegmentSize *dup() const override {return new NDPOptionMaxSegmentSize(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getMaxSegmentSize() const;
    virtual void setMaxSegmentSize(uint16_t maxSegmentSize);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPOptionMaxSegmentSize& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPOptionMaxSegmentSize& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:112</tt> by nedtool.
 * <pre>
 * class NDPOptionWindowScale extends NDPOption
 * {
 *     kind = NDPOPTION_WINDOW_SCALE;
 *     length = 3;
 *     unsigned short windowScale;   // uint8_t
 * }
 * </pre>
 */
class NDPOptionWindowScale : public ::inet::ndp::NDPOption
{
  protected:
    unsigned short windowScale;

  private:
    void copy(const NDPOptionWindowScale& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPOptionWindowScale&);

  public:
    NDPOptionWindowScale();
    NDPOptionWindowScale(const NDPOptionWindowScale& other);
    virtual ~NDPOptionWindowScale();
    NDPOptionWindowScale& operator=(const NDPOptionWindowScale& other);
    virtual NDPOptionWindowScale *dup() const override {return new NDPOptionWindowScale(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getWindowScale() const;
    virtual void setWindowScale(unsigned short windowScale);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPOptionWindowScale& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPOptionWindowScale& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:119</tt> by nedtool.
 * <pre>
 * class NDPOptionSackPermitted extends NDPOption
 * {
 *     kind = NDPOPTION_SACK_PERMITTED;
 *     length = 2;
 * }
 * </pre>
 */
class NDPOptionSackPermitted : public ::inet::ndp::NDPOption
{
  protected:

  private:
    void copy(const NDPOptionSackPermitted& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPOptionSackPermitted&);

  public:
    NDPOptionSackPermitted();
    NDPOptionSackPermitted(const NDPOptionSackPermitted& other);
    virtual ~NDPOptionSackPermitted();
    NDPOptionSackPermitted& operator=(const NDPOptionSackPermitted& other);
    virtual NDPOptionSackPermitted *dup() const override {return new NDPOptionSackPermitted(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPOptionSackPermitted& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPOptionSackPermitted& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:125</tt> by nedtool.
 * <pre>
 * class NDPOptionSack extends NDPOption
 * {
 *     kind = NDPOPTION_SACK;
 *     length = 2;     // 2 + getSackArraySize() * 8
 *     SackItem sackItem[];
 * }
 * </pre>
 */
class NDPOptionSack : public ::inet::ndp::NDPOption
{
  protected:
    SackItem *sackItem; // array ptr
    unsigned int sackItem_arraysize;

  private:
    void copy(const NDPOptionSack& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPOptionSack&);

  public:
    NDPOptionSack();
    NDPOptionSack(const NDPOptionSack& other);
    virtual ~NDPOptionSack();
    NDPOptionSack& operator=(const NDPOptionSack& other);
    virtual NDPOptionSack *dup() const override {return new NDPOptionSack(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setSackItemArraySize(unsigned int size);
    virtual unsigned int getSackItemArraySize() const;
    virtual SackItem& getSackItem(unsigned int k);
    virtual const SackItem& getSackItem(unsigned int k) const {return const_cast<NDPOptionSack*>(this)->getSackItem(k);}
    virtual void setSackItem(unsigned int k, const SackItem& sackItem);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPOptionSack& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPOptionSack& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:132</tt> by nedtool.
 * <pre>
 * class NDPOptionTimestamp extends NDPOption
 * {
 *     kind = NDPOPTION_TIMESTAMP;
 *     length = 10;
 *     uint32_t senderTimestamp;
 *     uint32_t echoedTimestamp;
 * }
 * </pre>
 */
class NDPOptionTimestamp : public ::inet::ndp::NDPOption
{
  protected:
    uint32_t senderTimestamp;
    uint32_t echoedTimestamp;

  private:
    void copy(const NDPOptionTimestamp& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPOptionTimestamp&);

  public:
    NDPOptionTimestamp();
    NDPOptionTimestamp(const NDPOptionTimestamp& other);
    virtual ~NDPOptionTimestamp();
    NDPOptionTimestamp& operator=(const NDPOptionTimestamp& other);
    virtual NDPOptionTimestamp *dup() const override {return new NDPOptionTimestamp(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSenderTimestamp() const;
    virtual void setSenderTimestamp(uint32_t senderTimestamp);
    virtual uint32_t getEchoedTimestamp() const;
    virtual void setEchoedTimestamp(uint32_t echoedTimestamp);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPOptionTimestamp& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPOptionTimestamp& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:140</tt> by nedtool.
 * <pre>
 * class NDPOptionUnknown extends NDPOption
 * {
 *     kind = -1;
 *     uint8_t bytes[];
 * }
 * </pre>
 */
class NDPOptionUnknown : public ::inet::ndp::NDPOption
{
  protected:
    uint8_t *bytes; // array ptr
    unsigned int bytes_arraysize;

  private:
    void copy(const NDPOptionUnknown& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPOptionUnknown&);

  public:
    NDPOptionUnknown();
    NDPOptionUnknown(const NDPOptionUnknown& other);
    virtual ~NDPOptionUnknown();
    NDPOptionUnknown& operator=(const NDPOptionUnknown& other);
    virtual NDPOptionUnknown *dup() const override {return new NDPOptionUnknown(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setBytesArraySize(unsigned int size);
    virtual unsigned int getBytesArraySize() const;
    virtual uint8_t getBytes(unsigned int k) const;
    virtual void setBytes(unsigned int k, uint8_t bytes);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDPOptionUnknown& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDPOptionUnknown& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transportlayer/Ndp/ndp_common/NDPSegment.msg:147</tt> by nedtool.
 * <pre>
 * packet NDPSegment
 * {
 *     \@customize(true);
 *     \@fieldNameSuffix("_var"); //TODO remove when OMNeT++ 4.x compatibility is no longer required
 * 
 *     // Source Port
 *     unsigned short srcPort;
 * 
 *     // Destination Port
 *     unsigned short destPort;
 * 
 *     // Sequence Number: first sequence number of the first data octet
 *     // in the respective segment (except if SYN is set; then the the
 *     // seq. number is the initial seq. number (ISS) and the first data
 *     // octet is ISS + 1)
 * //    unsigned int sequenceNo;
 * 
 *     // Acknowledgement Number: if ACK flag is set, this field contains
 *     // the next sequence number the sender of this segment is expecting
 *     // to receive
 *     unsigned int ackNo;
 * 
 *     unsigned int nackNo;
 * 
 *   // Added MOH
 * 
 * 
 * 
 *     bool isHeader;
 *     bool isPullPacket;
 *     bool isDataPacket;
 * 
 *     //   bool isSender;
 *     //   bool isReceiver;
 *     bool isLongFlow;
 *     unsigned int priorityValue;
 *     unsigned int numPacketsToSend;
 * 
 *     unsigned int pullSequenceNumber;
 *     unsigned int dataSequenceNumber;
 *     bool isLastPktToSend;
 *     bool ackBit; // ACK: ackNo significant if set
 *     bool nackBit; // ACK: ackNo significant if set
 * 
 *     // NDP Header Length - default: 20 bytes
 *     // if header options are used the headerLength is greater than 20 bytes (default)
 *     unsigned short headerLength = NDP_HEADER_OCTETS; // NDP_HEADER_OCTETS = 20
 * 
 *     bool urgBit; // URG: urgent pointer field significant if set
 * 
 * 
 * 
 *     bool pshBit; // PSH: push function
 *     bool rstBit; // RST: reset the connection
 *     bool synBit; // SYN: synchronize seq. numbers
 *     bool finBit; // FIN: finish - no more data from sender
 * 
 *     // Window Size: the number of data octets beginning with the one indicated
 *     // in the acknowledgement field which the sender of this segment is
 *     // willing to accept
 *     unsigned short window;
 * 
 *     // Urgent Pointer: communicates the current value of the urgent pointer
 *     // as a positive offset from the sequence number in this segment. The
 *     // urgent pointer points to the sequence number of the octet following
 *     // the urgent data. This field is only be interpreted in segments with
 *     // the URG control bit set.
 *     unsigned short urgentPointer;
 * 
 *     // Header options (optional)
 *     // Currently only EOL, NOP, MSS, WS, SACK_PERMITTED, SACK and TS are implemented
 *     abstract NDPOptionPtr headerOption[];
 * 
 *     // Payload length in octets (not an actual NDP header field).
 *     // This may not always be the same as encapsulatedPacket()->getByteLength();
 *     // e.g. when simulating a virtual data stream there's no encapsulated
 *     // packet at all.
 *     unsigned long payloadLength;
 * 
 *     // Message objects (cMessages) that travel in this segment as data.
 *     // This field is used only when the ~NDPDataTransferMode is NDP_TRANSFER_OBJECT.
 *     // Every message object is put into the NDPSegment that would (in real life)
 *     // carry its first octet. That is, if message object 'msg' with length=100 bytes
 *     // occupies stream offset number range 10000..10099, it will travel in the
 *     // NDPSegment which carries the octet 10000. This way it is easily achieved
 *     // that the receiving NDP passes up the message object to its client
 *     // when the last byte of the message has arrived.
 *     abstract NDPPayloadMessage payload[];
 * 
 *     // Message bytes that travel in this segment as data.
 *     // This field is used only when the ~NDPDataTransferMode is NDP_TRANSFER_BYTESTREAM.
 *     ByteArray byteArray;
 * }
 * </pre>
 *
 * NDPSegment_Base is only useful if it gets subclassed, and NDPSegment is derived from it.
 * The minimum code to be written for NDPSegment is the following:
 *
 * <pre>
 * class NDPSegment : public NDPSegment_Base
 * {
 *   private:
 *     void copy(const NDPSegment& other) { ... }

 *   public:
 *     NDPSegment(const char *name=nullptr, short kind=0) : NDPSegment_Base(name,kind) {}
 *     NDPSegment(const NDPSegment& other) : NDPSegment_Base(other) {copy(other);}
 *     NDPSegment& operator=(const NDPSegment& other) {if (this==&other) return *this; NDPSegment_Base::operator=(other); copy(other); return *this;}
 *     virtual NDPSegment *dup() const override {return new NDPSegment(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from NDPSegment_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(NDPSegment)
 * </pre>
 */
class NDPSegment_Base : public ::omnetpp::cPacket
{
  protected:
    unsigned short srcPort_var;
    unsigned short destPort_var;
    unsigned int ackNo_var;
    unsigned int nackNo_var;
    bool isHeader_var;
    bool isPullPacket_var;
    bool isDataPacket_var;
    bool isLongFlow_var;
    unsigned int priorityValue_var;
    unsigned int numPacketsToSend_var;
    unsigned int pullSequenceNumber_var;
    unsigned int dataSequenceNumber_var;
    bool isLastPktToSend_var;
    bool ackBit_var;
    bool nackBit_var;
    unsigned short headerLength_var;
    bool urgBit_var;
    bool pshBit_var;
    bool rstBit_var;
    bool synBit_var;
    bool finBit_var;
    unsigned short window_var;
    unsigned short urgentPointer_var;
    unsigned long payloadLength_var;
    ByteArray byteArray_var;

  private:
    void copy(const NDPSegment_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NDPSegment_Base&);
    // make constructors protected to avoid instantiation
    NDPSegment_Base(const char *name=nullptr, short kind=0);
    NDPSegment_Base(const NDPSegment_Base& other);
    // make assignment operator protected to force the user override it
    NDPSegment_Base& operator=(const NDPSegment_Base& other);

  public:
    virtual ~NDPSegment_Base();
    virtual NDPSegment_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class NDPSegment");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getSrcPort() const;
    virtual void setSrcPort(unsigned short srcPort);
    virtual unsigned short getDestPort() const;
    virtual void setDestPort(unsigned short destPort);
    virtual unsigned int getAckNo() const;
    virtual void setAckNo(unsigned int ackNo);
    virtual unsigned int getNackNo() const;
    virtual void setNackNo(unsigned int nackNo);
    virtual bool getIsHeader() const;
    virtual void setIsHeader(bool isHeader);
    virtual bool getIsPullPacket() const;
    virtual void setIsPullPacket(bool isPullPacket);
    virtual bool getIsDataPacket() const;
    virtual void setIsDataPacket(bool isDataPacket);
    virtual bool getIsLongFlow() const;
    virtual void setIsLongFlow(bool isLongFlow);
    virtual unsigned int getPriorityValue() const;
    virtual void setPriorityValue(unsigned int priorityValue);
    virtual unsigned int getNumPacketsToSend() const;
    virtual void setNumPacketsToSend(unsigned int numPacketsToSend);
    virtual unsigned int getPullSequenceNumber() const;
    virtual void setPullSequenceNumber(unsigned int pullSequenceNumber);
    virtual unsigned int getDataSequenceNumber() const;
    virtual void setDataSequenceNumber(unsigned int dataSequenceNumber);
    virtual bool getIsLastPktToSend() const;
    virtual void setIsLastPktToSend(bool isLastPktToSend);
    virtual bool getAckBit() const;
    virtual void setAckBit(bool ackBit);
    virtual bool getNackBit() const;
    virtual void setNackBit(bool nackBit);
    virtual unsigned short getHeaderLength() const;
    virtual void setHeaderLength(unsigned short headerLength);
    virtual bool getUrgBit() const;
    virtual void setUrgBit(bool urgBit);
    virtual bool getPshBit() const;
    virtual void setPshBit(bool pshBit);
    virtual bool getRstBit() const;
    virtual void setRstBit(bool rstBit);
    virtual bool getSynBit() const;
    virtual void setSynBit(bool synBit);
    virtual bool getFinBit() const;
    virtual void setFinBit(bool finBit);
    virtual unsigned short getWindow() const;
    virtual void setWindow(unsigned short window);
    virtual unsigned short getUrgentPointer() const;
    virtual void setUrgentPointer(unsigned short urgentPointer);
    virtual void setHeaderOptionArraySize(unsigned int size) = 0;
    virtual unsigned int getHeaderOptionArraySize() const = 0;
    virtual NDPOptionPtr& getHeaderOption(unsigned int k) = 0;
    virtual const NDPOptionPtr& getHeaderOption(unsigned int k) const {return const_cast<NDPSegment_Base*>(this)->getHeaderOption(k);}
    virtual void setHeaderOption(unsigned int k, const NDPOptionPtr& headerOption) = 0;
    virtual unsigned long getPayloadLength() const;
    virtual void setPayloadLength(unsigned long payloadLength);
    virtual void setPayloadArraySize(unsigned int size) = 0;
    virtual unsigned int getPayloadArraySize() const = 0;
    virtual NDPPayloadMessage& getPayload(unsigned int k) = 0;
    virtual const NDPPayloadMessage& getPayload(unsigned int k) const {return const_cast<NDPSegment_Base*>(this)->getPayload(k);}
    virtual void setPayload(unsigned int k, const NDPPayloadMessage& payload) = 0;
    virtual ByteArray& getByteArray();
    virtual const ByteArray& getByteArray() const {return const_cast<NDPSegment_Base*>(this)->getByteArray();}
    virtual void setByteArray(const ByteArray& byteArray);
};

} // namespace ndp
} // namespace inet

#endif // ifndef __INET__NDP_NDPSEGMENT_M_H

